// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// The Input Snapshot contains the set of all:
// * IssuedCertificates
// * PodBounceDirectives
// * DestinationRules
// * EnvoyFilters
// * Gateways
// * ServiceEntries
// * VirtualServices
// * AuthorizationPolicies
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package istio

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2"
	certificates_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2/sets"

	networking_istio_io_v1alpha3 "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3"
	networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"

	security_istio_io_v1beta1 "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1"
	security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"
)

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input IssuedCertificates
	IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	// return the set of input PodBounceDirectives
	PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// return the set of input DestinationRules
	DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet
	// return the set of input EnvoyFilters
	EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	// return the set of input Gateways
	Gateways() networking_istio_io_v1alpha3_sets.GatewaySet
	// return the set of input ServiceEntries
	ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet
	// return the set of input VirtualServices
	VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// return the set of input AuthorizationPolicies
	AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client) error

	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	issuedCertificates  certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	podBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	envoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	serviceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	virtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet

	authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet
}

func NewSnapshot(
	name string,

	issuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	podBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

) Snapshot {
	return &snapshot{
		name: name,

		issuedCertificates:    issuedCertificates,
		podBounceDirectives:   podBounceDirectives,
		destinationRules:      destinationRules,
		envoyFilters:          envoyFilters,
		gateways:              gateways,
		serviceEntries:        serviceEntries,
		virtualServices:       virtualServices,
		authorizationPolicies: authorizationPolicies,
	}
}

func (s snapshot) IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return s.issuedCertificates
}

func (s snapshot) PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return s.podBounceDirectives
}

func (s snapshot) DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return s.destinationRules
}

func (s snapshot) EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return s.envoyFilters
}

func (s snapshot) Gateways() networking_istio_io_v1alpha3_sets.GatewaySet {
	return s.gateways
}

func (s snapshot) ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return s.serviceEntries
}

func (s snapshot) VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return s.virtualServices
}

func (s snapshot) AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return s.authorizationPolicies
}
func (s snapshot) SyncStatuses(ctx context.Context, c client.Client) error {

	for _, obj := range s.IssuedCertificates().List() {
		if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
			return err
		}
	}

	return nil
}

func (s snapshot) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client) error {

	for _, obj := range s.IssuedCertificates().List() {
		clusterClient, err := mcClient.Cluster(obj.ClusterName)
		if err != nil {
			return err
		}
		if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
			return err
		}
	}

	return nil
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["issuedCertificates"] = s.issuedCertificates.List()
	snapshotMap["podBounceDirectives"] = s.podBounceDirectives.List()
	snapshotMap["destinationRules"] = s.destinationRules.List()
	snapshotMap["envoyFilters"] = s.envoyFilters.List()
	snapshotMap["gateways"] = s.gateways.List()
	snapshotMap["serviceEntries"] = s.serviceEntries.List()
	snapshotMap["virtualServices"] = s.virtualServices.List()
	snapshotMap["authorizationPolicies"] = s.authorizationPolicies.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
// Two types of builders are available:
// a builder for snapshots of resources across multiple clusters
// a builder for snapshots of resources within a single cluster
type Builder interface {
	BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error)
}

// Options for building a snapshot
type BuildOptions struct {

	// List options for composing a snapshot from IssuedCertificates
	IssuedCertificates ResourceBuildOptions
	// List options for composing a snapshot from PodBounceDirectives
	PodBounceDirectives ResourceBuildOptions

	// List options for composing a snapshot from DestinationRules
	DestinationRules ResourceBuildOptions
	// List options for composing a snapshot from EnvoyFilters
	EnvoyFilters ResourceBuildOptions
	// List options for composing a snapshot from Gateways
	Gateways ResourceBuildOptions
	// List options for composing a snapshot from ServiceEntries
	ServiceEntries ResourceBuildOptions
	// List options for composing a snapshot from VirtualServices
	VirtualServices ResourceBuildOptions

	// List options for composing a snapshot from AuthorizationPolicies
	AuthorizationPolicies ResourceBuildOptions
}

// Options for reading resources of a given type
type ResourceBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) Builder {
	return &multiClusterBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	podBounceDirectives := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()

	destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()

	authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertIssuedCertificatesFromCluster(ctx, cluster, issuedCertificates, opts.IssuedCertificates); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodBounceDirectivesFromCluster(ctx, cluster, podBounceDirectives, opts.PodBounceDirectives); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDestinationRulesFromCluster(ctx, cluster, destinationRules, opts.DestinationRules); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertEnvoyFiltersFromCluster(ctx, cluster, envoyFilters, opts.EnvoyFilters); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertGatewaysFromCluster(ctx, cluster, gateways, opts.Gateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertServiceEntriesFromCluster(ctx, cluster, serviceEntries, opts.ServiceEntries); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualServicesFromCluster(ctx, cluster, virtualServices, opts.VirtualServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAuthorizationPoliciesFromCluster(ctx, cluster, authorizationPolicies, opts.AuthorizationPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		authorizationPolicies,
	)

	return outputSnap, errs
}

func (b *multiClusterBuilder) insertIssuedCertificatesFromCluster(ctx context.Context, cluster string, issuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ResourceBuildOptions) error {
	issuedCertificateClient, err := certificates_mesh_gloo_solo_io_v1alpha2.NewMulticlusterIssuedCertificateClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "IssuedCertificate",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	issuedCertificateList, err := issuedCertificateClient.ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		issuedCertificates.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertPodBounceDirectivesFromCluster(ctx context.Context, cluster string, podBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, opts ResourceBuildOptions) error {
	podBounceDirectiveClient, err := certificates_mesh_gloo_solo_io_v1alpha2.NewMulticlusterPodBounceDirectiveClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "PodBounceDirective",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podBounceDirectiveList, err := podBounceDirectiveClient.ListPodBounceDirective(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podBounceDirectiveList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		podBounceDirectives.Insert(&item)
	}

	return nil
}

func (b *multiClusterBuilder) insertDestinationRulesFromCluster(ctx context.Context, cluster string, destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceBuildOptions) error {
	destinationRuleClient, err := networking_istio_io_v1alpha3.NewMulticlusterDestinationRuleClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	destinationRuleList, err := destinationRuleClient.ListDestinationRule(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range destinationRuleList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		destinationRules.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertEnvoyFiltersFromCluster(ctx context.Context, cluster string, envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceBuildOptions) error {
	envoyFilterClient, err := networking_istio_io_v1alpha3.NewMulticlusterEnvoyFilterClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	envoyFilterList, err := envoyFilterClient.ListEnvoyFilter(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range envoyFilterList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		envoyFilters.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertGatewaysFromCluster(ctx context.Context, cluster string, gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceBuildOptions) error {
	gatewayClient, err := networking_istio_io_v1alpha3.NewMulticlusterGatewayClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	gatewayList, err := gatewayClient.ListGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range gatewayList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		gateways.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertServiceEntriesFromCluster(ctx context.Context, cluster string, serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceBuildOptions) error {
	serviceEntryClient, err := networking_istio_io_v1alpha3.NewMulticlusterServiceEntryClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceEntryList, err := serviceEntryClient.ListServiceEntry(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceEntryList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		serviceEntries.Insert(&item)
	}

	return nil
}
func (b *multiClusterBuilder) insertVirtualServicesFromCluster(ctx context.Context, cluster string, virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceBuildOptions) error {
	virtualServiceClient, err := networking_istio_io_v1alpha3.NewMulticlusterVirtualServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceList, err := virtualServiceClient.ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualServices.Insert(&item)
	}

	return nil
}

func (b *multiClusterBuilder) insertAuthorizationPoliciesFromCluster(ctx context.Context, cluster string, authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceBuildOptions) error {
	authorizationPolicyClient, err := security_istio_io_v1beta1.NewMulticlusterAuthorizationPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	authorizationPolicyList, err := authorizationPolicyClient.ListAuthorizationPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range authorizationPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		authorizationPolicies.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	mgr manager.Manager
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewSingleClusterBuilder(
	mgr manager.Manager,
) Builder {
	return &singleClusterBuilder{
		mgr: mgr,
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	podBounceDirectives := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()

	destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()

	authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	var errs error

	if err := b.insertIssuedCertificates(ctx, issuedCertificates, opts.IssuedCertificates); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertPodBounceDirectives(ctx, podBounceDirectives, opts.PodBounceDirectives); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDestinationRules(ctx, destinationRules, opts.DestinationRules); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertEnvoyFilters(ctx, envoyFilters, opts.EnvoyFilters); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertGateways(ctx, gateways, opts.Gateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertServiceEntries(ctx, serviceEntries, opts.ServiceEntries); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualServices(ctx, virtualServices, opts.VirtualServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAuthorizationPolicies(ctx, authorizationPolicies, opts.AuthorizationPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		authorizationPolicies,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertIssuedCertificates(ctx context.Context, issuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "IssuedCertificate",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	issuedCertificateList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewIssuedCertificateClient(b.mgr.GetClient()).ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item // pike
		issuedCertificates.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertPodBounceDirectives(ctx context.Context, podBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "PodBounceDirective",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podBounceDirectiveList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewPodBounceDirectiveClient(b.mgr.GetClient()).ListPodBounceDirective(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podBounceDirectiveList.Items {
		item := item // pike
		podBounceDirectives.Insert(&item)
	}

	return nil
}

func (b *singleClusterBuilder) insertDestinationRules(ctx context.Context, destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	destinationRuleList, err := networking_istio_io_v1alpha3.NewDestinationRuleClient(b.mgr.GetClient()).ListDestinationRule(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range destinationRuleList.Items {
		item := item // pike
		destinationRules.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertEnvoyFilters(ctx context.Context, envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	envoyFilterList, err := networking_istio_io_v1alpha3.NewEnvoyFilterClient(b.mgr.GetClient()).ListEnvoyFilter(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range envoyFilterList.Items {
		item := item // pike
		envoyFilters.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertGateways(ctx context.Context, gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	gatewayList, err := networking_istio_io_v1alpha3.NewGatewayClient(b.mgr.GetClient()).ListGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range gatewayList.Items {
		item := item // pike
		gateways.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertServiceEntries(ctx context.Context, serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceEntryList, err := networking_istio_io_v1alpha3.NewServiceEntryClient(b.mgr.GetClient()).ListServiceEntry(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceEntryList.Items {
		item := item // pike
		serviceEntries.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertVirtualServices(ctx context.Context, virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceList, err := networking_istio_io_v1alpha3.NewVirtualServiceClient(b.mgr.GetClient()).ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item // pike
		virtualServices.Insert(&item)
	}

	return nil
}

func (b *singleClusterBuilder) insertAuthorizationPolicies(ctx context.Context, authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	authorizationPolicyList, err := security_istio_io_v1beta1.NewAuthorizationPolicyClient(b.mgr.GetClient()).ListAuthorizationPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range authorizationPolicyList.Items {
		item := item // pike
		authorizationPolicies.Insert(&item)
	}

	return nil
}
